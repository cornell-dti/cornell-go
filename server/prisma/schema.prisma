generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AuthType {
  GOOGLE
  APPLE
  DEVICE
  NONE
}

enum TimeLimitationType {
  LIMITED_TIME
  PERPETUAL
}

enum EnrollmentType {
  UNDERGRADUATE
  GRADUATE
  FACULTY
  ALUMNI
  GUEST
}

enum LocationType {
  ENG_QUAD
  ARTS_QUAD
  AG_QUAD
  CENTRAL_CAMPUS
  NORTH_CAMPUS
  WEST_CAMPUS
  CORNELL_ATHLETICS
  VET_SCHOOL
  COLLEGETOWN
  ITHACA_COMMONS
  ANY
}

enum AchievementType {
  TOTAL_POINTS
  TOTAL_CHALLENGES
  TOTAL_JOURNEYS
  TOTAL_CHALLENGES_OR_JOURNEYS
}

enum DifficultyMode {
  EASY
  NORMAL
  HARD
}

enum SessionLogEvent {
  JOIN_GROUP //data = groupId
  LEAVE_GROUP //data = groupId
  LOGIN_USER //data = userId
  CREATE_USER //data = userId
  DELETE_USER //data = userId
  EDIT_USERNAME //data = userId
  SELECT_EVENT //data = eventId
  DELETE_EVENT //data = eventId
  SET_CHALLENGE //data = challengeId
  DELETE_CHALLENGE //data = challengeId
  COMPLETE_CHALLENGE //data = challengeId
  DISCONNECT //data = ""
}

enum OrganizationSpecialUsage {
  ///DEVICE_LOGIN is a device assigned-id that acts as a user login for non-Cornell users.
  DEVICE_LOGIN
  CORNELL_LOGIN
  NONE
}

model User {
  id                     String               @id() @default(uuid())
  createdAt              DateTime             @default(now())
  updatedAt              DateTime             @updatedAt()
  subject                String               @default("User")
  authToken              String               @unique
  authType               AuthType
  username               String               @unique
  year                   String
  college                String
  major                  String
  interests              String[]
  email                  String
  hashedRefreshToken     String
  administrator          Boolean
  enrollmentType         EnrollmentType
  score                  Int
  isBanned               Boolean              @default(false)
  group                  Group                @relation("member", fields: [groupId], references: [id])
  groupId                String
  hostOf                 Group?               @relation("host")
  eventTrackers          EventTracker[]
  favorites              EventBase[]
  completedChallenges    PrevChallenge[]      @relation("owner")
  memberOf               Organization[]       @relation("orgToUser")
  managerOf              Organization[]       @relation("orgManager")
  isRanked               Boolean              @default(true)
  participatedIn         PrevChallenge[]      @relation("prevChallengeParticipant")
  sessionLogEntries      SessionLogEntry[]
  achievementTrackers    AchievementTracker[]
  challengeTimers        ChallengeTimer[]
  UserQuizAnswer         UserQuizAnswer[]
  hasCompletedOnboarding Boolean              @default(false)
}

model Group {
  id         String    @id @default(uuid())
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt()
  subject    String    @default("Group")
  friendlyId String    @unique
  members    User[]    @relation("member")
  host       User?     @relation("host", fields: [hostId], references: [id], onDelete: SetNull)
  hostId     String?   @unique
  curEvent   EventBase @relation(fields: [curEventId], references: [id])
  curEventId String
}

model Challenge {
  id             String          @id @default(uuid()) @map("id")
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt()
  subject        String          @default("Challenge")
  linkedEvent    EventBase?      @relation("all", fields: [linkedEventId], references: [id], onDelete: Cascade)
  linkedEventId  String?
  eventIndex     Int
  name           String
  location       LocationType
  description    String
  points         Int
  imageUrl       String
  latitude       Float
  longitude      Float
  awardingRadius Float
  closeRadius    Float
  timerLength    Int?
  completions    PrevChallenge[]
  activeTrackers EventTracker[]
  QuizQuestion   QuizQuestion[]
}

model EventBase {
  id              String             @id @default(uuid())
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt()
  subject         String             @default("EventBase")
  requiredMembers Int
  name            String
  description     String
  longDescription String
  timeLimitation  TimeLimitationType
  indexable       Boolean
  endTime         DateTime
  challenges      Challenge[]        @relation("all")
  userFavorite    User[]
  usedIn          Organization[]     @relation("eventOrgs")
  trackers        EventTracker[]
  activeGroups    Group[]
  latitude        Float
  longitude       Float
  achievements    Achievement[]
  difficulty      DifficultyMode
  category        EventCategoryType
}

enum EventCategoryType {
  FOOD
  NATURE
  HISTORICAL
  CAFE
  DININGHALL
  DORM
}

model EventTracker {
  id                  String          @id @default(uuid())
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt()
  subject             String          @default("EventTracker")
  user                User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId              String
  score               Int
  hintsUsed           Int
  isRankedForEvent    Boolean         @default(true)
  event               EventBase       @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId             String
  curChallenge        Challenge?      @relation(fields: [curChallengeId], references: [id], onDelete: SetNull)
  curChallengeId      String?
  completedChallenges PrevChallenge[]
}

model PrevChallenge {
  id             Int          @id @default(autoincrement())
  subject        String       @default("PrevChallenge")
  user           User         @relation("owner", fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  participants   User[]       @relation("prevChallengeParticipant")
  challenge      Challenge    @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  challengeId    String
  tracker        EventTracker @relation(fields: [trackerId], references: [id], onDelete: Cascade)
  trackerId      String
  hintsUsed      Int
  extensionsUsed Int          @default(0)
  timestamp      DateTime     @default(now())
  failed         Boolean      @default(false) // True if challenge was failed due to timer expiration
}

model Organization {
  id           String                   @id @default(uuid())
  createdAt    DateTime                 @default(now())
  updatedAt    DateTime                 @updatedAt()
  subject      String                   @default("Organization")
  name         String
  accessCode   String
  members      User[]                   @relation("orgToUser")
  managers     User[]                   @relation("orgManager")
  events       EventBase[]              @relation("eventOrgs")
  specialUsage OrganizationSpecialUsage
  achievements Achievement[]
}

model SessionLogEntry {
  id         String          @id @default(uuid())
  subject    String          @default("SessionLogEntry")
  linkedUser User?           @relation(fields: [userId], references: [id])
  eventType  SessionLogEvent
  data       String
  timestamp  DateTime        @default(now())
  userId     String?
}

model Achievement {
  id              String               @id @default(uuid())
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt()
  subject         String               @default("Achievement")
  requiredPoints  Int
  name            String
  description     String
  imageUrl        String
  linkedEvent     EventBase?           @relation(fields: [linkedEventId], references: [id])
  linkedEventId   String?
  locationType    LocationType
  achievementType AchievementType
  trackers        AchievementTracker[]
  organizations   Organization[]
}

model AchievementTracker {
  id            String      @id @default(uuid())
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt()
  subject       String      @default("AchievementTracker")
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  progress      Int
  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)
  dateComplete  DateTime?
  achievementId String
  userId        String
}

enum ChallengeTimerStatus {
  ACTIVE
  GRACE_PERIOD // Timer expired but waiting for potential extension (prevents race condition)
  COMPLETED
  EXPIRED
  PAUSED
  CANCELLED
}

model ChallengeTimer {
  id                    String               @id @default(uuid())
  subject               String               @default("ChallengeTimer")
  timerLength           Int                  @default(600) //in seconds
  startTime             DateTime             @default(now())
  endTime               DateTime?
  currentStatus         ChallengeTimerStatus @default(ACTIVE)
  extensionsUsed        Int                  @default(0) //number of extensions used for this timer
  originalBasePoints    Int //original points challenge would give (if no extensions used)
  // warnings
  warningMilestones     Int[]                @default([]) //milestones to send warnings for
  warningMilestonesSent Int[]                @default([]) //which milestones have been sent
  lastWarningSent       DateTime? //when last warning was sent
  // relationships 
  user                  User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId                String
  challengeId           String

  @@unique([userId, challengeId]) //one timer per user per challenge
}

model QuizQuestion {
  id          String    @id @default(cuid())
  challengeId String
  challenge   Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)

  questionText String
  explanation  String?
  difficulty   Int     @default(1)
  pointValue   Int     @default(10)
  category     String  @default("HISTORICAL")

  answers     QuizAnswer[]
  userAnswers UserQuizAnswer[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("QuizQuestion")
}

model QuizAnswer {
  id         String       @id @default(cuid())
  questionId String
  question   QuizQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)

  answerText String
  isCorrect  Boolean @default(false)

  userSelections UserQuizAnswer[]

  @@map("QuizAnswer")
}

model UserQuizAnswer {
  id               String       @id @default(cuid())
  userId           String
  user             User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  questionId       String
  question         QuizQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  selectedAnswerId String?
  selectedAnswer   QuizAnswer?  @relation(fields: [selectedAnswerId], references: [id], onDelete: SetNull)

  isCorrect    Boolean
  pointsEarned Int
  answeredAt   DateTime @default(now())

  @@unique([userId, questionId]) // Enforce one attempt per question
  @@map("UserQuizAnswer")
}
